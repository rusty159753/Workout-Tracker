import streamlit as st
import datetime
import pytz
import json
import re
import unicodedata
import hashlib
from bs4 import BeautifulSoup

# --- 1. CONFIGURATION ---
st.set_page_config(page_title="TRI DRIVE", page_icon="‚ö°")

# --- 2. GLOBAL STYLES (High Contrast) ---
st.markdown("""
<style>
    div[data-testid="stAlert"], div[data-testid="stNotification"] {
        background-color: #172b4d !important;
        border: 1px solid #3b5e8c !important;
        color: #ffffff !important;
    }
    div[data-testid="stAlert"] *, div[data-testid="stNotification"] * {
        color: #ffffff !important;
        fill: #ffffff !important;
    }
    div[data-testid="stAlert"] p, div[data-testid="stNotification"] p {
        font-size: 16px;
        line-height: 1.6;
    }
</style>
""", unsafe_allow_html=True)

# --- 3. DIAGNOSTICS ---
with st.sidebar:
    st.header("üîß System Operations")
    if st.button("‚ö†Ô∏è Hard Reset System", type="primary"):
        st.session_state.clear()
        st.rerun()

# --- 4. DEPENDENCIES ---
try:
    import cloudscraper
    READY_TO_SYNC = True
    st.sidebar.success("Core Systems: ONLINE")
except ImportError:
    READY_TO_SYNC = False
    st.sidebar.error("Core Systems: OFFLINE")

# --- 5. SESSION STATE ---
if 'view_mode' not in st.session_state:
    st.session_state['view_mode'] = 'VIEWER'
if 'current_wod' not in st.session_state:
    st.session_state['current_wod'] = {}

# --- 6. UTILITY: The Anti-Mashing Janitor ---
def sanitize_text(text):
    if not text: return ""
    
    # A. Artifact Replacement
    replacements = {
        "√¢": "'", "‚Äô": "'", "‚Äò": "'", 
        "‚Äú": '"', "‚Äù": '"', 
        "‚Äì": "-", "‚Äî": "-", "‚Ä¶": "..."
    }
    for bad, good in replacements.items():
        text = text.replace(bad, good)

    # B. Structural Parsing
    soup = BeautifulSoup(text, "html.parser")
    
    # 1. Handle Line Breaks
    for br in soup.find_all("br"):
        br.replace_with("\n")
        
    # 2. Handle List Items
    for li in soup.find_all("li"):
        li.insert_before("\n‚Ä¢ ")
        li.insert_after("\n")
        
    # 3. Handle Paragraphs & Headers
    for block in soup.find_all(['p', 'div', 'h1', 'h2', 'h3', 'h4']):
        block.insert_before("\n\n")
        block.insert_after("\n\n")

    # 4. Extract Text with SPACE separator to prevent mashing
    text = soup.get_text(separator=" ", strip=True)
    
    # C. Cleanup & Normalization
    text = unicodedata.normalize("NFKD", text)
    
    # Fix the "Resources" mash in cues
    text = text.replace("Resources:", "\n\nResources:")
    
    # Collapse massive gaps
    text = re.sub(r'\n{3,}', '\n\n', text)
    # Fix multiple spaces generated by the separator
    text = re.sub(r'[ \t]+', ' ', text)
    
    return text.strip()

# --- 7. CORE LOGIC: The Mapper ---
def parse_workout_data(wod_data):
    if isinstance(wod_data, str):
        full_blob = sanitize_text(wod_data)
        title = "Workout of the Day"
    else:
        raw_main = wod_data.get('main_text', '')
        raw_stim = wod_data.get('stimulus', '')
        full_blob = sanitize_text(raw_main + "\n\n" + raw_stim)
        title = wod_data.get('title', 'Workout of the Day')

    headers = {
        "Stimulus": re.compile(r"(Stimulus\s+and\s+Strategy|Stimulus):", re.IGNORECASE),
        "Scaling": re.compile(r"(Scaling|Scaling Options):", re.IGNORECASE),
        "Intermediate": re.compile(r"Intermediate\s+option:", re.IGNORECASE),
        "Beginner": re.compile(r"Beginner\s+option:", re.IGNORECASE),
        "Cues": re.compile(r"(Coaching\s+cues|Coaching\s+Tips):", re.IGNORECASE)
    }

    indices = []
    for key, pattern in headers.items():
        match = pattern.search(full_blob)
        if match:
            indices.append({"key": key, "start": match.start(), "end": match.end()})
    
    indices.sort(key=lambda x: x['start'])
    
    parsed = {
        "workout": "", "strategy": "", "scaling": "", 
        "intermediate": "", "beginner": "", "cues": "",
        "title": title
    }

    workout_end = indices[0]['start'] if indices else len(full_blob)
    workout_text = full_blob[:workout_end].strip()
    
    footer_match = re.search(r"(Post\s+time\s+to\s+comments|Post\s+rounds\s+to\s+comments|Post\s+to\s+comments)", workout_text, re.IGNORECASE)
    if footer_match:
        parsed['workout'] = workout_text[:footer_match.start()].strip()
    else:
        parsed['workout'] = workout_text

    for i, item in enumerate(indices):
        key = item['key']
        start = item['end']
        end = indices[i+1]['start
  st.warning("‚ö†Ô∏è Phase 3 Pending Authorization")
            
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
("‚ö†Ô∏è Phase 3 Pending Authorization")
            
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
          st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
formatted_rx}")
            
            st.warning("‚ö†Ô∏è Phase 3 Pending Authorization")
            
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
formatted_rx}")
            
            st.warning("‚ö†Ô∏è Phase 3 Pending Authorization")
            
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
              with st.expander("Coaching Cues"):
                        st.markdown(wod['cues'].replace("\n", "  \n"))

            else:
                st.error("Data integrity failure. Perform Hard Reset.")

    elif st.session_state['view_mode'] == 'WORKBENCH':
        st.caption("üõ†Ô∏è WORKBENCH ACTIVE")
        wod = st.session_state.get('current_wod', {})
        
        if not wod:
            st.error("Memory buffer empty.")
            if st.button("Return to Base"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
        else:
            st.success(f"Loaded: {wod.get('title', 'Unknown')}")
            
            formatted_rx = wod.get('workout', 'No Data').replace("\n", "  \n")
            st.markdown(f"**Target Workout:** \n{formatted_rx}")
            
            st.warning("‚ö†Ô∏è Phase 3 Pending Authorization")
            
            if st.button("‚¨ÖÔ∏è Abort & Return"):
                st.session_state['view_mode'] = 'VIEWER'
                st.rerun()
